# 工程化

- [工程化](#工程化)
  - [安全](#安全)
  - [Linux 的常用命令](#linux-的常用命令)
  - [前端优化](#前端优化)
  - [Tree Shaking](#tree-shaking)
  - [webpack配置有哪些](#webpack配置有哪些)
  - [webpack的魔法注释](#webpack的魔法注释)
  - [webpak如何实现预加载](#webpak如何实现预加载)
  - [webpack编译原理](#webpack编译原理)
  - [vite的编译原理](#vite的编译原理)
  - [babel是什么，babel的原理，用babel做了什么](#babel是什么babel的原理用babel做了什么)
  - [plugin和loader的区别](#plugin和loader的区别)
  - [webpack的loader有哪些](#webpack的loader有哪些)
  - [webpack的plugin有哪些](#webpack的plugin有哪些)
  - [前端权限控制的理解，有哪些？](#前端权限控制的理解有哪些)
  - [做过服务监控，数据埋点吗？](#做过服务监控数据埋点吗)

### 安全

- xss
  1. XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等
      - 存储型 xss（常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等）
        1. 攻击者将恶意代码提交到目标网站的数据库中。
        2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
        3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
        4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
      - 反射型 xss（常见于通过 URL 传递参数的功能，如网站搜索、跳转等）
        1. 攻击者构造出特殊的 URL，其中包含恶意代码。
        2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
        3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
        4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
      - dom 型 xss（）
        - 攻击者构造出特殊的 URL，其中包含恶意代码。
        - 用户打开带有恶意代码的 URL。
        - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
        - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
  2. 预防措施
      - 转义字符过滤 html 代码
      - 过滤 SQL 代码
      - http-only
      - 前端能少使用innerhtml等，多使用createElement等
      - 采用验证码
- CSRF
  1. CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的
  2. 预防措施
      - 验证 HTTP Referer 字段
      - token
      - Get 请求不对数据进行修改
      - 接口防跨域处理
- 点击劫持
  点击劫持是指在一个 Web 页面中隐藏了一个透明的 iframe，用外层假页面诱导用户点击，实际上是在隐藏的 frame 上触发了点击事件进行一些用户不知情的操作。
- SQL 注入
  它是利用现有应用程序，将(恶意) 的 SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表单中输入 (恶意) SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句。

### Linux 的常用命令

- cd 切换目录
- pwd 显示当前目录完整路径
- ls (-a) 查看目录下的信息（包括隐藏文件）
- ll 列出目录下的文件和详细信息
- mkdir 目录名 创建目录
- touch 文件名.后缀名 添加文件
- rm (-rf) 删除文件（目录）
- scp 上传文件至服务器
- which 找出可执行文件
- cat (-n) 文件名 查勘文件的内容 （显示行号）
- vim 文件名 编辑文件的内容
  - i 切换到输入模式，以输入字符
  - : 切换到底线命令模式，以在最底一行输入命令；
  - a 切换到输入文字模式；
  - 按 esc 之后
    - :q 退出程序；
    - :q! 放弃对文件内容的修改并退出；
    - :w 保存文件；
    - :w /root/xx 另存为；
    - :wq 保存文件并退出；

### 前端优化

- content 方面
  1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  2. 减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名
  3. 优化图片，对于小图片可以使用 base64，能用 css 实现的就少用图片
- Server 方面
  1. 使用 CDN
  2. 开启缓存
  3. 对组件使用 Gzip 压缩
- js 或者 css 方面
  1. 将样式表放到页面顶部，脚本放到页面底部
  2. 将 javascript 和 css 从外部引入。
  3. 压缩 javascript 和 css
  4. 删除不需要的脚本，资源按需引入，路由按需下载
  5. 避免使用 css 表达式，减少 DOM 访问

### Tree Shaking

- 定义：Tree Shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination

- 原理：
  - ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块。
  - 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码。

### webpack配置有哪些

- entry
- output
- loader
- plugin

- 作用
  - 模块打包
  - 编译兼容
  - 能力扩展

### webpack的魔法注释

主要为了实现懒下载，在打包的时候会根据chunkName来打成一个块的文件，这样就达到了分割的效果，实现了按需下载。

### webpak如何实现预加载

1. 使用prefetch预加载模块资源： 在Webpack的配置文件中，可以通过optimization.prefetch配置来进行资源的预加载
2. 使用preload预加载关键资源： 在Webpack的配置文件中，可以通过HtmlWebpackPlugin插件的配置来进行资源的预加载

### webpack编译原理

Webpack 是一个现代的静态模块打包工具，它的主要目标是将多个文件作为输入，通过模块依赖关系进行分析，然后将这些文件打包成一个或多个最终的输出文件。Webpack 的编译原理可以概括为以下几个主要步骤：

入口分析：Webpack 会根据配置文件中的入口点（entry point）来开始分析项目的依赖关系。入口可以是一个或多个 JavaScript 文件，也可以是其他的资源文件。

依赖解析：Webpack 会递归地解析入口文件及其依赖的模块，找出所有的依赖关系。Webpack 支持多种模块化语法和文件类型，如 ES6 模块、CommonJS、AMD、CSS、图片等。

模块转换：Webpack 会对每个模块执行对应的转换操作。它使用加载器（loader）来处理不同类型的模块，例如使用 Babel 加载器来转译 ES6+ 语法，使用 CSS 加载器来处理 CSS 文件。

代码分割：Webpack 支持代码的动态分割和按需加载，通过识别模块间的动态依赖关系，将代码拆分成更小的块（chunk）并进行异步加载，以提升应用的性能和加载速度。

模块合并：在转换和分割模块后，Webpack 将根据配置文件中的规则，将模块合并成一个或多个最终的输出文件，通常是一个 JavaScript 文件 bundle。输出文件可以经过额外的处理，如压缩、文件指纹等。

代码优化：Webpack 会对生成的代码进行优化，如去除无用的代码（Tree Shaking）、压缩 JavaScript 和 CSS、提取公共模块等，以减小文件体积和提升运行效率。

以上步骤是 webpack 的主要编译原理流程，通过分析模块依赖关系、转换模块内容、合并最终代码等步骤，Webpack 能够将项目中的多个模块打包成最终可在浏览器中运行的代码文件。这样，开发者可以使用更现代化的模块化开发方式，充分发挥模块化的优势，并实现更好的项目管理和性能优化。

简要回答：
webpack是一种静态模块打包工具，将单个或多个文件导入，通过模块分析进行分析，并且进行相应的操作，比如说转换，优化等等，最后输出单个或多个文件，主要流程如下：1入口分析，将一个文件或多个文件导入并进行分析其依赖关系，2依赖解析，webpack会递归解析入口文件的所有的依赖关系，3模块转换，webpack会对每个模块进行相应的转换操作，比如说babel，css等，4代码优化，合并分割模块，压缩代码，提取公共模块等，5输出，将最终的代码输出到指定的文件中。

### vite的编译原理

Vite 是一个构建工具，专为现代化的前端开发而设计。它的原理是基于 ES Modules（ESM）和浏览器原生模块系统（Native Browser Module System）。相比传统的打包工具，Vite 利用浏览器原生的模块加载能力，实现了一种更快、更轻量级的开发体验。

下面是 Vite 的主要原理：

开发服务器：Vite 在开发模式下运行一个轻量级的开发服务器。当请求一个模块时，开发服务器会通过解析请求路径，找到对应的模块文件。

ESM 转换：Vite 的开发服务器会将模块文件进行逐个解析，并将其转换为浏览器可以直接执行的格式，即转换成符合 ES Modules 规范的代码。这个过程使用了 Rollup 进行单文件的转换和优化。

按需编译：Vite 会根据模块的实际使用情况，进行按需编译。即只编译当前请求的模块及其直接依赖模块，而不是像传统的打包工具那样将所有模块打包到一个 bundle 中。这样可以提高开发的速度和性能，避免不必要的重新构建。

模块代理：为了解决浏览器环境下无法直接使用 ESM 的 import 语法加载资源文件（如 CSS、图片等）的问题，Vite 使用模块代理的方式，在开发服务器中提供了对这些资源文件的处理和优化，同时也支持模块热更新。

静态资源处理：Vite 对于一些静态资源（如图片、字体等）采用了类似模块代理的方式进行处理，在开发服务器中提供了对这些资源的解析和优化，使其可以通过浏览器原生的模块加载方式进行加载。

生产构建：在生产环境中，Vite 会将所有的模块文件通过 Rollup 进行打包，并进行压缩、混淆等优化操作，生成最终的生产代码。

总体而言，Vite 利用了浏览器原生的模块加载能力和现代浏览器的支持，通过按需编译和模块代理等技术手段，提供了快速启动和开发体验，在开发环境下实现了秒级的冷启动和热模块替换。它不需要像传统打包工具那样将所有模块打包到一个大的 bundle 中，能够更高效地利用浏览器的缓存和网络请求，并且能够更好地利用现有的浏览器原生模块系统，使前端开发更加高效和灵活。

简要回答：
vite是一种构建工具，主要利用es modules和原生浏览器的模块系统，vite通过该模块加载能力，实现快速的响应，主要流程如下：1建立服务器，vite生成一个服务器，这样可以通过相对路径去找对应的资源和文件以及模块，2esm转换，vite需要将模块转换成浏览器支持的格式，3按需编译，vite会根据模块的实际使用情况来进行编译，4模块代理，静态资源处理，vite会处理浏览器不支持的方法，比如说import，静态图片等等，5生产构建，这主要采用了rollup的构建工具来进行打包，压缩等等最终生成最代码

### babel是什么，babel的原理，用babel做了什么

- 定义：babel是一种js编译器，主要将es6+这些新版语法向后兼容，方便低版本浏览器支持。
- 原理：

    1. 解析：将代码解析成抽象语法树AST
    2. 转换：对抽象语法树进行转换操作
    3. 生成：根据转换后的抽象语法树再生成代码
- 场景：
  1. 语法转换：将ES6+语法转换成ES5语法，以便低版本浏览器支持
  2. 代码转换：将JSX转换成React.createElement()函数调用
  3. 通过Polyfill方式在目标环境中添加缺失的特性，比如Promise、Set等新对象
  4. 优化代码，比如删除无用代码、优化重复代码等

### plugin和loader的区别

- loader：webpack中的loader是用来加载资源文件的，比如说css-loader、style-loader、file-loader等，它是一个导出为函数的js模块，接受源文件作为参数，返回转换的结果。
- plugin：plugin是用来扩展webpack功能的，它会在整个构建过程中生效，执行相关的任务，比如清除dist目录、压缩代码、拷贝静态文件等，它是一个具有apply方法的js对象，apply方法会被webpack compiler调用，并且compiler对象可在整个编译生命周期访问。

### webpack的loader有哪些

1. babel-loader将es6语法转为es5语法
2. css-loader加载css文件并解析import的css文件，最终返回css码
3. ts-loader将加载js一样加载ts
4. html-loader将html导出字符串，需要传入静态资源的引用路径
5. less-loader/sass-loader/stylus-loader/postcss-loader编译对应的css预处理器
6. vue-loader加载vue文件并编译

### webpack的plugin有哪些

1. MiniCssExtractPlugin 为每一个包含了 CSS 的 JS 文件创建一个 CSS 文件
2. HtmlWebpackPlugin该插件将为你生成一个 HTML5 文件， 在 body 中使用 script 标签引入你所有 webpack 生成的 bundle
3. CommonsChunkPlugin提取 chunk 之间的公共模块用以共享

### 前端权限控制的理解，有哪些？

1. 路由级别权限控制（页面级别权限控制）： 在前端应用中，可以通过路由配置来控制用户可以访问的页面。在登录后，根据用户的权限级别，动态生成可访问的路由列表，并在路由跳转前进行权限验证，判断用户是否有权限访问该路由。如果没有权限，可以跳转到相应的错误页面或进行其他处理
2. 组件级别权限控制： 可以在组件级别进行权限控制，通过在组件中进行权限判断，决定是否渲染或展示该组件。根据用户的权限级别，可以在组件中使用条件语句、路由守卫或自定义指令等方式来进行判断和控制
3. UI 层面权限控制： 在前端 UI 层面，可以根据用户的权限级别，展示或隐藏相应的操作按钮、菜单项或功能。这样用户在界面上只能看到对其权限可见的选项，从而降低误操作的可能性
4. API接口权限控制：在与后端交互时，可以在接口层面进行权限控制。前端发送请求时，携带相应的身份令牌或权限信息，后端进行验证，判断用户是否有权限执行该请求

### 做过服务监控，数据埋点吗？

做过服务监控，使用sentry来做性能监控和错误跟踪上报，采用sentry的api进行操作，在sentry的中央服务器进行查阅，并找出相应的问题和错误处理，以及性能问题，上家公司做了数据埋点的插件库，主要作于按钮点击，图片点击得知用户的一切行为，以及用户的行为路径，以及用户的行为习惯。
