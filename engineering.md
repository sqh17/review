# 工程化

### 安全

- xss
  1. XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等
      - 存储型 xss（常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等）
        1. 攻击者将恶意代码提交到目标网站的数据库中。
        2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
        3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
        4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
      - 反射型 xss（常见于通过 URL 传递参数的功能，如网站搜索、跳转等）
        1. 攻击者构造出特殊的 URL，其中包含恶意代码。
        2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
        3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
        4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
      - dom 型 xss（）
        - 攻击者构造出特殊的 URL，其中包含恶意代码。
        - 用户打开带有恶意代码的 URL。
        - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
        - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
  2. 预防措施
      - 转义字符过滤 html 代码
      - 过滤 SQL 代码
      - http-only
      - 前端能少使用innerhtml等，多使用createElement等
      - 采用验证码
- CSRF
  1. CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的
  2. 预防措施
      - 验证 HTTP Referer 字段
      - token
      - Get 请求不对数据进行修改
      - 接口防跨域处理
- 点击劫持
  点击劫持是指在一个 Web 页面中隐藏了一个透明的 iframe，用外层假页面诱导用户点击，实际上是在隐藏的 frame 上触发了点击事件进行一些用户不知情的操作。
- SQL 注入
  它是利用现有应用程序，将(恶意) 的 SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表单中输入 (恶意) SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句。

### Linux 的常用命令

- cd 切换目录
- pwd 显示当前目录完整路径
- ls (-a) 查看目录下的信息（包括隐藏文件）
- ll 列出目录下的文件和详细信息
- mkdir 目录名 创建目录
- touch 文件名.后缀名 添加文件
- rm (-rf) 删除文件（目录）
- scp 上传文件至服务器
- which 找出可执行文件
- cat (-n) 文件名 查勘文件的内容 （显示行号）
- vim 文件名 编辑文件的内容
  - i 切换到输入模式，以输入字符
  - : 切换到底线命令模式，以在最底一行输入命令；
  - a 切换到输入文字模式；
  - 按 esc 之后
    - :q 退出程序；
    - :q! 放弃对文件内容的修改并退出；
    - :w 保存文件；
    - :w /root/xx 另存为；
    - :wq 保存文件并退出；

### 前端优化

- content 方面
  1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  2. 减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名
  3. 优化图片，对于小图片可以使用 base64，能用 css 实现的就少用图片
- Server 方面
  1. 使用 CDN
  2. 开启缓存
  3. 对组件使用 Gzip 压缩
- js 或者 css 方面
  1. 将样式表放到页面顶部，脚本放到页面底部
  2. 将 javascript 和 css 从外部引入。
  3. 压缩 javascript 和 css
  4. 删除不需要的脚本，资源按需引入，路由按需下载
  5. 避免使用 css 表达式，减少 DOM 访问

### Tree Shaking

- 定义：Tree Shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination

- 原理：
  - ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块。
  - 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码。

### webpack配置有哪些

- entry
- output
- loader
- plugin

- 作用
  - 模块打包
  - 编译兼容
  - 能力扩展

### webpack的魔法注释

主要为了实现懒下载，在打包的时候会根据chunkName来打成一个块的文件，这样就达到了分割的效果，实现了按需下载。

### webpack编译原理

Webpack 是一个现代的静态模块打包工具，它的主要目标是将多个文件作为输入，通过模块依赖关系进行分析，然后将这些文件打包成一个或多个最终的输出文件。Webpack 的编译原理可以概括为以下几个主要步骤：

入口分析：Webpack 会根据配置文件中的入口点（entry point）来开始分析项目的依赖关系。入口可以是一个或多个 JavaScript 文件，也可以是其他的资源文件。

依赖解析：Webpack 会递归地解析入口文件及其依赖的模块，找出所有的依赖关系。Webpack 支持多种模块化语法和文件类型，如 ES6 模块、CommonJS、AMD、CSS、图片等。

模块转换：Webpack 会对每个模块执行对应的转换操作。它使用加载器（loader）来处理不同类型的模块，例如使用 Babel 加载器来转译 ES6+ 语法，使用 CSS 加载器来处理 CSS 文件。

代码分割：Webpack 支持代码的动态分割和按需加载，通过识别模块间的动态依赖关系，将代码拆分成更小的块（chunk）并进行异步加载，以提升应用的性能和加载速度。

模块合并：在转换和分割模块后，Webpack 将根据配置文件中的规则，将模块合并成一个或多个最终的输出文件，通常是一个 JavaScript 文件 bundle。输出文件可以经过额外的处理，如压缩、文件指纹等。

代码优化：Webpack 会对生成的代码进行优化，如去除无用的代码（Tree Shaking）、压缩 JavaScript 和 CSS、提取公共模块等，以减小文件体积和提升运行效率。

以上步骤是 webpack 的主要编译原理流程，通过分析模块依赖关系、转换模块内容、合并最终代码等步骤，Webpack 能够将项目中的多个模块打包成最终可在浏览器中运行的代码文件。这样，开发者可以使用更现代化的模块化开发方式，充分发挥模块化的优势，并实现更好的项目管理和性能优化。

### vite的编译原理

Vite 是一个构建工具，专为现代化的前端开发而设计。它的原理是基于 ES Modules（ESM）和浏览器原生模块系统（Native Browser Module System）。相比传统的打包工具，Vite 利用浏览器原生的模块加载能力，实现了一种更快、更轻量级的开发体验。

下面是 Vite 的主要原理：

开发服务器：Vite 在开发模式下运行一个轻量级的开发服务器。当请求一个模块时，开发服务器会通过解析请求路径，找到对应的模块文件。

ESM 转换：Vite 的开发服务器会将模块文件进行逐个解析，并将其转换为浏览器可以直接执行的格式，即转换成符合 ES Modules 规范的代码。这个过程使用了 Rollup 进行单文件的转换和优化。

按需编译：Vite 会根据模块的实际使用情况，进行按需编译。即只编译当前请求的模块及其直接依赖模块，而不是像传统的打包工具那样将所有模块打包到一个 bundle 中。这样可以提高开发的速度和性能，避免不必要的重新构建。

模块代理：为了解决浏览器环境下无法直接使用 ESM 的 import 语法加载资源文件（如 CSS、图片等）的问题，Vite 使用模块代理的方式，在开发服务器中提供了对这些资源文件的处理和优化，同时也支持模块热更新。

静态资源处理：Vite 对于一些静态资源（如图片、字体等）采用了类似模块代理的方式进行处理，在开发服务器中提供了对这些资源的解析和优化，使其可以通过浏览器原生的模块加载方式进行加载。

生产构建：在生产环境中，Vite 会将所有的模块文件通过 Rollup 进行打包，并进行压缩、混淆等优化操作，生成最终的生产代码。

总体而言，Vite 利用了浏览器原生的模块加载能力和现代浏览器的支持，通过按需编译和模块代理等技术手段，提供了快速启动和开发体验，在开发环境下实现了秒级的冷启动和热模块替换。它不需要像传统打包工具那样将所有模块打包到一个大的 bundle 中，能够更高效地利用浏览器的缓存和网络请求，并且能够更好地利用现有的浏览器原生模块系统，使前端开发更加高效和灵活。
