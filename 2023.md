## 开头

2023年为了备战面试，从其他的面试题或者想到的问题总结如下。

#### 能简单自我介绍一下吗

你好，面试官，我叫史庆浩，一直从事于前端开发工作，有6年的工作经验，我熟练掌握HTML，CSS和js，能够快速编写符合最佳实践的可维护可易读的代码，对前端框架，ui库以及库工具都有深入的了解，尤其是vue全家桶，曾经研究过源代码，也开发过以react为框架的项目，也对服务端有所了解，包括node，mysql，nginx，曾经在项目中使用，也对webpcak，vite等打包工具有所了解，除了技术能力，我也注重团队合作和沟通，曾在项目中协调资源，保证项目顺利完成，除此之外，也对前端保持的热情，关注前沿技术，最后希望加入贵公司，贡献自己的一份力量，谢谢。

#### 最长递增子序列

- 解法1-动态规划

```javascript
var lengthOfLIS = function(nums) {
    if(nums.length<=0) return 0
    let dp = new Array(nums.length).fill(1)
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp)
};
```

- 解法2-贪心+二分查找

```javascript
function getSequence(arr) {
  const len = arr.length
  const min_arr = [0] // 存储最小的索引，以索引0为基准
  const prev_arr = arr.slice() // 储存前面的索引，slice为浅复制一个新的数组
  let last_index
  let start
  let end
  let middle
  for (let i = 0; i < len; i++) {
    let arrI = arr[i]
    // 1. 如果当前n比min_arr最后一项大
    last_index = min_arr[min_arr.length - 1]
    if (arr[last_index] < arrI) {
      min_arr.push(i)
      prev_arr[i] = last_index // 前面的索引
      continue
    }
    // 2. 如果当前n比min_arr最后一项小（二分类查找）
    start = 0
    end = min_arr.length - 1
    while(start < end) {
      middle = (start + end) >> 1 // 相当于Math.floor((start + end)/2)
      if (arr[min_arr[middle]] < arrI) {
        start = middle + 1
      } else  {
        end = middle
      }
    }
    if (arr[min_arr[end]] > arrI) {
      min_arr[end] = i
      if (end > 0) {
        prev_arr[i] = min_arr[end - 1] // 前面的索引
      }
    }
  }

  // 从最后一项往前查找
  let result = []
  let i = min_arr.length
  let last = min_arr[i - 1]
  while(i-- > 0) {
    result[i] = last
    last = prev_arr[last]
  }

  return result.length
}

```

#### 如何把一个字符串当成js执行（动态执行js）

```javascript
function exec(code){
  // todo
}
exec('console.log("a")')
```

有以下几个方法：

- eval 同步方式，作用于当前作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  eval(code)
}
exec('console.log("a", a)')
console.log('sync')
```

- setTimeout 异步方式，作用于全局作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  setTimeout(code,0)
}
exec('console.log("a", a)')
console.log('sync')
```

- 创建document元素 同步方式，作用于全局作用域，（多了个引入的方式）

```javascript
var a = 1
function exec(code){
  var a = 2;
  const doc = document.createElement('script')
  doc.innerHTML = code
  document.body.appendChild(doc)
}
exec('console.log("a", a)')
console.log('sync')
```

- new一个Function 同步方式，作用于全局作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  const fn = Function(code)
  fn()
}
exec('console.log("a", a)')
console.log('sync')
```

#### vue3的特性

之前已汇总到note里，可参考[https://github.com/sqh17/notes/blob/master/ways/vue3/%E7%89%B9%E6%80%A7%26%E5%8C%BA%E5%88%AB%26%E6%9E%B6%E6%9E%84%26%E9%92%A9%E5%AD%90.md](!<https://github.com/sqh17/notes/blob/master/ways/vue3/%E7%89%B9%E6%80%A7%26%E5%8C%BA%E5%88%AB%26%E6%9E%B6%E6%9E%84%26%E9%92%A9%E5%AD%90.md>
下面是面试回答:
vue3相对于vue2有了更大的变化，vue3的新特性主要包含以下部分：

1. 采用新的响应式原理，用ES6的proxy代替ES5的Object.defineProperty，主要解决了对象，数组的更新检测，优化了性能
2. 采用composition api，方便逻辑复用
3. 采用新的虚拟dom算法，使用patchFlag标记，不用一个一个去比较，而是通过patch flag去进行相应的更新。
4. template 模板可以有多个根元素 Fragment
5. tree-shaking，分包，按需加载
6. 采用Typescript进行源码编写，更好类型推导，更严谨。

#### vue3相对于vue2的区别

之前已汇总到note里，可参考[https://github.com/sqh17/notes/blob/master/ways/vue3/%E7%89%B9%E6%80%A7%26%E5%8C%BA%E5%88%AB%26%E6%9E%B6%E6%9E%84%26%E9%92%A9%E5%AD%90.md](!https://github.com/sqh17/notes/blob/master/ways/vue3/%E7%89%B9%E6%80%A7%26%E5%8C%BA%E5%88%AB%26%E6%9E%B6%E6%9E%84%26%E9%92%A9%E5%AD%90.md)
下面是面试回答:
vue3相对于vue2的区别主要分为以下部分：

1. 向下兼容，vue3可以兼容vue2的写法
2. vue3对比vue2具有明显的性能提升，打包容量更小，渲染速度更快
3. 使用Proxy代替defineProperty实现响应式数据

    1. vue2的大部分问题不能监听到对象属性的添加和删除，需要Vue.set()来添加和删除，不能通过下标替换元素或更新length，所以会重写部分数组的方法。
    2. vue3通过Proxy拦截对data任意属性的任意操作, 包括属性值的读写, 属性的添加, 属性的删除等
4. 性能提升
    1. 静态标记，vue2从根节点开始对虚拟dom进行全量对比，vue3新增了静态标记 与上次虚拟dom对比的时候，只对比带有 patchFlags 的节点。跳过一些静态节点对比
    2. 静态提升，vue2里每当触发更新的时候，不管元素是否参与更新，每次都会重新创建；vue3为了避免每次渲染的时候都要重新创建这些对象，会把不参与更新的元素保存起来，只创建一次，每次复用
    3. 事件缓存，vue2里绑定事件都要重新生成新的function去更新，vue3会自动生成一个内联函数，同时生成一个静态节点。onclick时会读取缓存，如果缓存没有的话，就把传入的事件存到缓存里

#### vue绑定原理

在初始化时，Vue 通过代理（Proxy）或 Object.defineProperty 方法对对象数据的 getter 和 setter 进行劫持。当数据发生改变时，这些 getter 和 setter 方法会被触发。接下来就是依赖收集的过程，当属性被访问时，在 getter 方法中会创建一个 Watcher 对象，并将该 Watcher 对象添加到对应属性的依赖收集器（Dep）中。当属性发生改变时，会触发 setter 方法，通知对应的 Dep 进行通知操作，进而触发依赖收集器中保存的 Watcher 对象进行更新操作，从而实现数据的响应式更新。

#### vue2和vue3的diff算法区别

1. vue2的diff算法依靠的是双指针的方式，从根节点开始一层一层将新节点和旧节点进行比较，然后再进行dom增删改
2. vue3的diff算法是新增了一个静态标记，将每个节点都有对应的静态标记，当进行createblock方法的时候，会忽略所有的静态节点，直接通过patchFlag去找对应的节点然后进行don增删改

#### vue3 setup

setup是个语法糖，用于替代 Vue 2 中的 beforeCreate 和 created 钩子函数，并提供更直接的响应式数据、计算属性、方法等

#### vue3的watch和watchEffect的区别

1. watch是显式监听某个值或响应对象，当这些发生变化后会触发对应的回调函数
2. watchEffect 会自动追踪函数内部的响应式依赖，无需显式指定要观察的数据，回调函数不接收参数

#### v-model原理

v-model实际上就是一个语法糖，它会根据标签的不同，自动转换成不同的属性，比如input标签，会转换成value和input事件，select标签会转换成value和change事件，textarea标签会转换成value和input事件。
他将这些表单元素的值和data里的对象进行绑定，当表单元素的值发生变化的时候，会触发对应的事件，从而改变data里的值，当data里的值发生变化的时候，会触发对应的事件，从而改变表单元素的值，这样实现了双向绑定。

#### v-model自定义组件的实现

通过props和emit触发父组件的事件，实现双向绑定，比如通过input事件触发父组件的update:modelValue事件，然后通过modelValue属性传递给子组件，子组件通过emit触发input事件，从而实现双向绑定。

#### keep-alive原理

通过keep-alive标签，将组件包裹起来，放进内存中，切换的时候是不会被销毁的，下次切换的时候直接读缓存中的组件实例，但dom并不会保存，根据组件最近使用状态，采用lru缓存策略，销毁很久没使用的组件实例，从而达到缓存的目的。

下次进来的时候是进activated钩子函数，跳过beforeCreate和created

#### vue是如何收集依赖的

vue有个依赖收集机制，vue通过proxy/defineproperty对data进行劫持，当读取data的属性的时候，会触发get方法，将当前的watcher添加到dep中，当修改data的属性的时候，会触发set方法，通知dep中的watcher进行更新。这样，页面上相关的组件会得到更新，保持与数据的同步。

#### vue的template到render的过程

1. 解析template，生成ast语法树，遍历模板的每个节点，并其转为对应的ast节点
2. 优化静态节点，标记静态节点，标记出那些在渲染过程中保持不变的静态节点。静态节点在渲染时会被标记，并且每次渲染时会被复用，从而提升渲染性能
3. 生成render函数，将ast语法树转成render函数
4. 生成虚拟dom，将render函数执行，生成虚拟dom，比较，更新
5. 生成真实dom，将虚拟dom转成真实dom

#### 将以下class类转成构造函数模式的写法

```javascript
class Example {
  constructor(name){
    this.name = name
  }
  fun(){
    console.log('hello,',name)
  }
}
```

```javascript

'use strict'; 

function Example(){
  if(!new.target) {
    throw new TypeError('必须用new关键字 调用')
  }
  this.name = name
}
Object.defineProperty(Example.prototype, 'func', {
  value(){
    if(new.target){
      throw new TypeError('构造函数的方法不能使用new关键字调用')
    }
    console.log('hello,',this.name)
  },
  enumerable: false
})
```

汇总：

  1. 严格模式
  2. new 创建对象
  3. 类中方法不可枚举
  4. 类中方法不可使用new

#### 面试题

```javascript
// 实现以下的写法
add[1][2][3] + 4 // 10
add[100][200] + 300 // 600
add[10][20][30] + 40 // 100
```

```javascript
function createFunc(values = []){
  return new Proxy({},{
    get(targe, p){
      if(p === Symbol.toPrimitive){
        return () => values.reduce((a,b)=>a + b, 0)
      }
      return createFunc([...values], +p)
    }
  })
}
let add = createFunc()
```

#### 面试题

```javascript
// 输出多少
console.log(++[[]][+[]] + [+[]])
```

```javascript
console.log(++[[]][+[]] + [+[]]) // '10'
```

解析：

  1. 先把`+[]`转成原始类型，隐式转换依次调用valueOf()还是`[]`，再调用toString()，是空字符串''，所以这个是`0`
  2. `[[]]`,代表的是数组的第一项是空数组,所以`[[]][0]`还是空数组`[]`
  3. `++[]`,现将`[]`隐式转换为`0`，所以`++0`是数字1
  4. `[+[]]`按照第一步，代表是`[0]`,所以隐式转换为`'0'`,
  5. 整体后就是 `1 + '0'` 所以是字符串10

#### 新版本发布后，怎么用技术手段通知用户刷新页面

1. websocket：若应用中使用了websocket，与服务器建立实时通信的连接。当服务器端检测到新版本发布时，可以通过 WebSocket 向客户端发送消息，告知用户有新版本可用，并建议用户刷新页面
2. cookie/localstorage：在用户登录后，服务器可以向客户端设置一个特殊的 Cookie 或 Local Storage 值，用于标记是否有新版本发布。客户端可以在每次加载页面时检查该值，并根据情况提示用户有新版本可用，并提供刷新页面的选项。
3. Service Worker：Service Worker 是一个在浏览器后台运行的脚本，可以拦截和处理网络请求。你可以编写一个 Service Worker 脚本，在检测到新版本发布时，在用户访问站点时显示一个提醒，提示用户有新版本可用，并提供按钮或交互方式来触发页面的刷新
4. Push API：（未接触过），Push API 是一种现代网页浏览器提供的 API，用于实现将消息推送到用户设备的功能。它允许服务器端向客户端发送通知，即使用户并未在浏览器中打开相关网页也可以接收到

#### 知不知道最新的 url 参数获取的 API

new URLSearchParams(window.location.search)

#### link和@import的区别

1. @import是css提供的语法糖，只有导入css，link标签是html提供的标签，可以导入css，也可以定义RSS，rel链接符等
2. 加载页面不同，link引入css可以同时加载，不阻塞，但@import引入的css只能在页面加载完毕后再加载
3. 兼容性问题，link不存在兼容性问题，@import是css2有的，老式浏览器不支持
4. js操作，link可以操作link标签，但是@import是基于文档，无法操作

#### react原理

react是通过组件的状态和虚拟dom比较的方式实现的，当状态发生变化时，React 会重新渲染只有发生变化的部分，从而提高性能。这种基于状态更新和虚拟 DOM 的比较是 React 的核心机制，保证了组件的高效更新和视图的响应性。单向数据流。

#### 使用 React 进行性能优化时，采取哪些措施

1. 列表渲染确保唯一key
2. 避免在 render 方法中直接绑定函数，可以使用箭头函数或将函数绑定到类的实例上，以避免在每次渲染时创建新的函数
3. 使用 React 的 Fragment 或空标签（<>…</>）来取代不必要的包裹元素，减少生成的 DOM 节点数量
4. 将较大的组件拆分成较小的子组件，以提高组件的可读性和可维护性，并能更好地利用 React 的重渲染优化策略
5. 使用 React 的 lazy 和 Suspense 功能来延迟加载和渲染组件，以减少页面的初始加载时间
6. 使用 useMemo 和 useCallback 函数来缓存计算结果和事件处理函数，避免不必要的计算和函数重复创建
7. 使用应用程序状态管理库（如 Redux、Mobx）来避免不必要的组件重渲染，并在组件之间共享数据和状态

#### vue、react数据绑定的区别

#### preload和prefecth

1. preload预加载
  指示浏览器在页面加载期间请求和加载指定的资源。它会在网页的 \<head> 标签中使用 \<link> 元素来声明需要预加载的资源，如 CSS 文件、字体、脚本等,减少后续的请求的延迟
2. prefectch预取
  指示浏览器在空闲时间加载指定的资源。它通过在 \<head> 标签中使用 \<link> 元素声明资源，告诉浏览器哪些资源可能会在将来的导航中使用
