## 开头

2023年为了备战面试，从其他的面试题或者想到的问题总结如下。

#### 最长递增子序列

- 解法1-动态规划

```javascript
var lengthOfLIS = function(nums) {
    if(nums.length<=0) return 0
    let dp = new Array(nums.length).fill(1)
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp)
};
```

- 解法2-贪心+二分查找

```javascript
function getSequence(arr) {
  const len = arr.length
  const min_arr = [0] // 存储最小的索引，以索引0为基准
  const prev_arr = arr.slice() // 储存前面的索引，slice为浅复制一个新的数组
  let last_index
  let start
  let end
  let middle
  for (let i = 0; i < len; i++) {
    let arrI = arr[i]
    // 1. 如果当前n比min_arr最后一项大
    last_index = min_arr[min_arr.length - 1]
    if (arr[last_index] < arrI) {
      min_arr.push(i)
      prev_arr[i] = last_index // 前面的索引
      continue
    }
    // 2. 如果当前n比min_arr最后一项小（二分类查找）
    start = 0
    end = min_arr.length - 1
    while(start < end) {
      middle = (start + end) >> 1 // 相当于Math.floor((start + end)/2)
      if (arr[min_arr[middle]] < arrI) {
        start = middle + 1
      } else  {
        end = middle
      }
    }
    if (arr[min_arr[end]] > arrI) {
      min_arr[end] = i
      if (end > 0) {
        prev_arr[i] = min_arr[end - 1] // 前面的索引
      }
    }
  }

  // 从最后一项往前查找
  let result = []
  let i = min_arr.length
  let last = min_arr[i - 1]
  while(i-- > 0) {
    result[i] = last
    last = prev_arr[last]
  }

  return result.length
}

```

#### 如何把一个字符串当成js执行（动态执行js）

```javascript
function exec(code){
  // todo
}
exec('console.log("a")')
```

有以下几个方法：

- eval 同步方式，作用于当前作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  eval(code)
}
exec('console.log("a", a)')
console.log('sync')
```

- setTimeout 异步方式，作用于全局作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  setTimeout(code,0)
}
exec('console.log("a", a)')
console.log('sync')
```

- 创建document元素 同步方式，作用于全局作用域，（多了个引入的方式）

```javascript
var a = 1
function exec(code){
  var a = 2;
  const doc = document.createElement('script')
  doc.innerHTML = code
  document.body.appendChild(doc)
}
exec('console.log("a", a)')
console.log('sync')
```

- new一个Function 同步方式，作用于全局作用域

```javascript
var a = 1
function exec(code){
  var a = 2;
  const fn = Function(code)
  fn()
}
exec('console.log("a", a)')
console.log('sync')
```

#### vue3的特性

之前已汇总到note里，可参考[](!)
下面是面试回答:
vue3相对于vue2有了更大的变化，vue3的新特性主要包含以下部分：

1. 采用新的响应式原理，用ES6的proxy代替ES5的Object.defineProperty，主要解决了对象，数组的更新检测，优化了性能
2. 采用composition api，方便逻辑复用
3. 采用新的虚拟dom算法，使用patchFlag标记，不用一个一个去比较，而是通过patch flag去进行相应的更新。
4. template 模板可以有多个根元素 Fragment
5. tree-shaking，分包，按需加载
6. 采用Typescript进行源码编写，更好类型推导，更严谨。

#### vue3相对于vue2的区别

之前已汇总到note里，可参考[](!)
下面是面试回答:
vue3相对于vue2的区别主要分为以下部分：

1. 向下兼容，vue3可以兼容vue2的写法
2. vue3对比vue2具有明显的性能提升，打包容量更小，渲染速度更快
3. 使用Proxy代替defineProperty实现响应式数据

    1. vue2的大部分问题不能监听到对象属性的添加和删除，需要Vue.set()来添加和删除，不能通过下标替换元素或更新length，所以会重写部分数组的方法。
    2. vue3通过Proxy拦截对data任意属性的任意操作, 包括属性值的读写, 属性的添加, 属性的删除等
4. 性能提升
    1. 静态标记，vue2从根节点开始对虚拟dom进行全量对比，vue3新增了静态标记 与上次虚拟dom对比的时候，只对比带有 patchFlags 的节点。跳过一些静态节点对比
    2. 静态提升，vue2里每当触发更新的时候，不管元素是否参与更新，每次都会重新创建；vue3为了避免每次渲染的时候都要重新创建这些对象，会把不参与更新的元素保存起来，只创建一次，每次复用
    3. 事件缓存，vue2里绑定事件都要重新生成新的function去更新，vue3会自动生成一个内联函数，同时生成一个静态节点。onclick时会读取缓存，如果缓存没有的话，就把传入的事件存到缓存里
